<!DOCTYPE HTML>
<html>

    <head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<meta name="description" content="Your description">
	<meta name="author" content="Dan Bernstein">
	<meta name="generator" content="Hugo 0.40.3" />
	<title>DC Bike Crash Analysis &middot; Data By Dan</title>
	<!-- Stylesheets -->
	
	<link rel="stylesheet" href="https://danbernstein.netlify.com/css/main.css"/>
	
	

	

	<!-- Custom Fonts -->
	<link href="https://danbernstein.netlify.com/css/font-awesome.min.css" rel="stylesheet" type="text/css">

	
	<link rel="shortcut icon" type="image/x-icon" href="https://danbernstein.netlify.com/favicon.ico">
	<link rel="icon" type="image/x-icon" href="https://danbernstein.netlify.com/favicon.ico">
	

	<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
	<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
	<!--[if lt IE 9]>
	<script src="js/ie/html5shiv.js"></script>
	<script src="js/ie/html5shiv.jsrespond.min.js"></script>
	<![endif]-->
</head>
    <body>

    <!-- Wrapper -->
        <div id="wrapper">

            <!-- Header -->
    <header id="header" class="alt">
        <a href="https://danbernstein.netlify.com/" class="logo"><strong>Forty</strong> <span>By HTML5 Up</span></a>
        <nav>
            <a href="#menu">Menu</a>
        </nav>
    </header>

<!-- Menu -->
    <nav id="menu">
        <ul class="links">
            
                <li><a href="https://danbernstein.netlify.com/">Home</a></li>
            
                <li><a href="https://danbernstein.netlify.com/post/about-dan">About Dan</a></li>
            
                <li><a href="https://danbernstein.netlify.com/post/cv">Resume</a></li>
            

        </ul>
        <ul class="actions vertical">
            
            
        </ul>
    </nav>

        <!-- Main -->
            <div id="main" class="alt">

                
                    <section id="one">
                        <div class="inner">
                            <header class="major">
                                <h1>DC Bike Crash Analysis</h1>
                            </header>
                            
                            <p>The number of bike lanes in DC have proliferated in the past few years, ostensibly providing cyclists with increased safety. However, not all bike lanes are created equal: protected bike lanes with intermittent posts provide greater protection than bike lanes sandwiched between busy streets and parking lanes along the curb. This analysis intends to determine if bike lanes have increased safety, measured in terms of the number of reported crashes involving a cyclist. It will further explore how the various types of bike lanes impact incident rates.</p>
<div id="study-questions" class="section level2">
<h2>Study questions:</h2>
<ol style="list-style-type: decimal">
<li><p>Does a new bike lane lead to a reduction in annual reported crashes after installation?</p></li>
<li><p>Do bike lane configurations differ in their protective effect on instances of reported crashes?</p></li>
</ol>
</div>
<div id="methods" class="section level2">
<h2>Methods:</h2>
<div id="overview-of-analysis" class="section level3">
<h3><em>Overview of Analysis</em></h3>
<p>The workflow for this analysis includes:</p>
<ul>
<li>Download the necessary data from <a href="http://opendata.dc.gov/">opendata.dc.gov</a></li>
<li>Find a fitting control group of street segments without bike lanes to use for comparison through Propensity Score Matching</li>
<li>Count the number of reported crashes that occur on each street segment in the years before and after the bike lane is installed</li>
<li>Analyze the differences in count between the roads with and without bike lanes before and after installation</li>
</ul>
</div>
<div id="data" class="section level3">
<h3><em>Data</em></h3>
<p>All data was acquired from the DC government’s <a href="http://opendata.dc.gov/datasets/">data portal</a> in early July 2018. Specifically, I am using the District Department of Transportation’s (DDOT) <a href="http://opendata.dc.gov/datasets/crashes-in-dc">Crashes in DC</a> dataset, which provides the geographic locations of all crashes and summary statistics, including totals individuals injured by mode of transportation (pedestrian, bicycle, car) and how severe the injuries were (minor, major, fatal). The related <a href="http://opendata.dc.gov/datasets/crash-details-table">Crash details dataset</a> provides additional information on the parties to the incident, including age and whether speeding was involved. Crash reports involving bicycles appear as early as 2011, and continue through the data collection in 2018.</p>
<p>This data was analyzed alongside DDOT’s <a href="http://opendata.dc.gov/datasets/bicycle-lanes">Bicycle Lanes dataset</a>, which provides information on all existing and proposed bike lanes in DC. Bike lanes are reported with the year they were installed, starting in the year 1980, and then no occurrences reported until 2001, and then new reported entries occur every year thereafter. The <a href="http://opendata.dc.gov/datasets/street-centerlines?geometry=-77.824%2C38.707%2C-76.809%2C39.081">Street Centerlines dataset</a> provides the geospatial location for all streets in DC, with attributes including the direction (one-way, two-way, etc.) and street classification (street, alley, freeway, etc.). These attributes will be important later for finding appropriate streets for comparison. Initial visualization was conducted in qGIS v2.18 for ease of use, while statistical analysis was conducted in R 3.4.4.</p>
<pre class="r"><code># spatial tools 
library(rgdal)
library(maptools)
library(spatstat)
library(geosphere)
library(sf)
library(rgeos)
# other packages
library(MatchIt) # for propensity score matching
library(dplyr) # for data manipulation
library(tidyr)

## read in the shapefiles
lanes.shp.raw &lt;- sf::st_read(dsn = &quot;./markdown_data/crash_analysis_dc/bikelanes&quot;, 
                     layer = &quot;Bicycle_Lanes&quot;)

streets.shp.raw &lt;- sf::st_read(dsn = &quot;./markdown_data/crash_analysis_dc/dc_streets&quot;,
                       layer = &quot;Street_Centerlines&quot;) %&gt;% 
  # combine the two entries for one way roadways into one for purposes of matching
  mutate(directionality = case_when(DIRECTIONA == &quot;Two way&quot; ~ &quot;Two way&quot;,
                                    DIRECTIONA == &quot;Unknown&quot; ~ &quot;Unknown&quot;,
                                    TRUE ~ &quot;One way&quot;))

lanes &lt;- lanes.shp.raw %&gt;% 
  filter(YEAR_INSTA &gt;= 2014) </code></pre>
</div>
<div id="propensity-score-matching-with-segment-level-attributes" class="section level3">
<h3>Propensity score matching with segment-level attributes</h3>
<p><em>This section gives an application of Propensity Score Matching in R. For a more comprehensive, step-by-step guide to propensity score matching, see <a href="https://pareonline.net/getvn.asp?v=19&amp;n=18">this example</a> from Randolph, et al. They give a great gentle introduction and hands-on example that anyone can use. A <a href="https://www.r-bloggers.com/using-the-r-matchit-package-for-propensity-score-analysis/">blog post</a> on R-bloggers shows how the outputs of a matched dataset can be analyzed like any other dataset, but with greater certainty in the results.</em></p>
<p>With a limited number of roads with bike lanes, we need to find a fitting comparison set of roads without bike lanes that are similar in terms of variables that might impact the number of reported crashes. A 2012 paper from the American Journal of Public Health <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3483943/">identified</a> three useful covariates for matching to determine the impact of bike lanes: 1-way vs. 2-way roadways (directionality), divided vs. undivided roadways, and number of lanes on the road. The DC street centerlines dataset includes directionality, with four options (“Two way”, “One way (digitizing direction)”, “One way (against digitizing direction”, “Unknown”). The two options denoting one way directionality were combined because the information about digitizing direction is irrelevant to this analysis. While the data does not include information on divided vs. undivided roadways or the number of lanes, I will also match on the length of the roads and the road type (street, alley, driveway, ramp, or service road).</p>
<pre class="r"><code># data preparation for Propensity Score Matching
join.df &lt;- 
# left join bike lanes data to streets data 
  st_join(streets.shp.raw, lanes) %&gt;% 
# denote the treatment group
  mutate(bike_lane = case_when(!is.na(BIKELANE_Y) ~ 1,
                               TRUE ~ 0),
# create and id variable to allow for merging data after matching
         rowid = row_number()) 

# subset only the variables that are complete, including the row id and the matching variables
join.match.df &lt;- join.df %&gt;% 
  select(rowid, bike_lane, ROADTYPE, directionality, SHAPELEN)

# create a bike lane identification data frame that will be used later to ensure matched entries # use the same reference year in counting crashes before and after installation year
lane_status &lt;- join.df %&gt;% 
  select(rowid, bike_lane, YEAR_INSTA) %&gt;% 
  filter(!is.na(YEAR_INSTA))</code></pre>
<p>MatchIt implements Propensity Score Matching through the MatchIt function. After this pre-processing to match treatment observations with control observations, we can carry out any normal statistical analyses as you might with an unmatched dataset.</p>
<p>We can evaluate the quality of the matched pairs. For each variable used in the matching algorithm, the summary includes statistical distribution information for the full dataset, the matched dataset, and the percent improvement.</p>
<pre class="r"><code>summary(m.out)</code></pre>
<pre><code>## 
## Call:
## matchit(formula = bike_lane ~ ROADTYPE + directionality + SHAPELEN, 
##     data = join.match.df, ratio = 2)
## 
## Summary of balance for all data:
##                       Means Treated Means Control SD Control Mean Diff
## distance                     0.0342        0.0232     0.0159    0.0110
## ROADTYPEAlley                0.0912        0.2678     0.4428   -0.1765
## ROADTYPEDriveway             0.0250        0.0701     0.2554   -0.0451
## ROADTYPERamp                 0.0150        0.0167     0.1283   -0.0017
## ROADTYPEServiceRoad          0.0012        0.0037     0.0607   -0.0024
## ROADTYPEStreet               0.8675        0.6417     0.4795    0.2258
## directionalityTwo way        0.6912        0.8754     0.3303   -0.1841
## directionalityUnknown        0.0000        0.0002     0.0134   -0.0002
## SHAPELEN                    95.9459       84.0853    83.9743   11.8606
##                       eQQ Med eQQ Mean  eQQ Max
## distance               0.0028   0.0109   0.0345
## ROADTYPEAlley          0.0000   0.1762   1.0000
## ROADTYPEDriveway       0.0000   0.0462   1.0000
## ROADTYPERamp           0.0000   0.0025   1.0000
## ROADTYPEServiceRoad    0.0000   0.0025   1.0000
## ROADTYPEStreet         0.0000   0.2262   1.0000
## directionalityTwo way  0.0000   0.1838   1.0000
## directionalityUnknown  0.0000   0.0012   1.0000
## SHAPELEN               9.7560  11.7084 654.9765
## 
## 
## Summary of balance for matched data:
##                       Means Treated Means Control SD Control Mean Diff
## distance                     0.0342        0.0342     0.0198    0.0000
## ROADTYPEAlley                0.0912        0.0875     0.2827    0.0038
## ROADTYPEDriveway             0.0250        0.0269     0.1618   -0.0019
## ROADTYPERamp                 0.0150        0.0175     0.1312   -0.0025
## ROADTYPEServiceRoad          0.0012        0.0019     0.0433   -0.0006
## ROADTYPEStreet               0.8675        0.8662     0.3405    0.0013
## directionalityTwo way        0.6912        0.6894     0.4629    0.0019
## directionalityUnknown        0.0000        0.0000     0.0000    0.0000
## SHAPELEN                    95.9459       96.0405    99.9910   -0.0946
##                       eQQ Med eQQ Mean eQQ Max
## distance               0.0000   0.0000  0.0007
## ROADTYPEAlley          0.0000   0.0038  1.0000
## ROADTYPEDriveway       0.0000   0.0012  1.0000
## ROADTYPERamp           0.0000   0.0025  1.0000
## ROADTYPEServiceRoad    0.0000   0.0000  0.0000
## ROADTYPEStreet         0.0000   0.0012  1.0000
## directionalityTwo way  0.0000   0.0025  1.0000
## directionalityUnknown  0.0000   0.0000  0.0000
## SHAPELEN               0.1273   0.4529 16.4675
## 
## Percent Balance Improvement:
##                       Mean Diff. eQQ Med eQQ Mean  eQQ Max
## distance                 99.9705 99.9929  99.9640  97.8789
## ROADTYPEAlley            97.8754  0.0000  97.8723   0.0000
## ROADTYPEDriveway         95.8463  0.0000  97.2973   0.0000
## ROADTYPERamp            -43.1979  0.0000   0.0000   0.0000
## ROADTYPEServiceRoad      74.4681  0.0000 100.0000 100.0000
## ROADTYPEStreet           99.4465  0.0000  99.4475   0.0000
## directionalityTwo way    98.9817  0.0000  98.6395   0.0000
## directionalityUnknown   100.0000  0.0000 100.0000 100.0000
## SHAPELEN                 99.2024 98.6955  96.1322  97.4858
## 
## Sample sizes:
##           Control Treated
## All         33262     800
## Matched      1600     800
## Unmatched   31662       0
## Discarded       0       0</code></pre>
</div>
<div id="defining-the-pre--and-post-installation-years" class="section level3">
<h3>Defining the pre- and post-installation years</h3>
<p>Before we introduce the crash point data, we need to manipulate the matched treatment and control observationss to define the pre and post-installation years for the control group (street segments without bike lanes). This is complicated by the fact that bike lanes are installed in different years, so we can not use a single numeric value to differentiate between pre and post-installation periods. We have a few options:</p>
<ul>
<li>we might separate the dataset into individual datasets for each year that bike lanes were installed. Then use a unique range of years for each dataset to define the pre and post-installation years to aggregate data points.</li>
<li>we can link the installation year for line segments with bike lanes to the matched line segments in the control group and then define the pre and post-installation periods by adding constant values.</li>
</ul>
<p>We will pursue the second solution because it is more flexible and adaptable to other datasets.</p>
<p>The match matrix within the MatchIt object includes and n x ratio matrix where the row numbers are equivalent to the row indices of the treatment observations in the input data. While the input data does not include bike lane installation years (because MatchIt requires no missing data), we can use the row indices to link the match matrix to the bike lane installation year information (stored in “lane_status”).</p>
<pre class="r"><code># prepare the match matrix to merge the installation year of bike lanes to the matched control observations
match.matr &lt;- as.data.frame(m.out$match.matrix) %&gt;% 
  mutate(rowid = row_number()) %&gt;% 
  mutate(rowid = lane_status$rowid) %&gt;% 
  rename(&quot;match_1&quot; = `1`, &quot;match_2&quot; = `2`) %&gt;% 
  mutate_if(is.factor, function(x){as.integer(as.character(x))}) %&gt;% 
  left_join(., lane_status, by = &quot;rowid&quot;)

join.match2 &lt;-
  join.match.df %&gt;% 
# join the first and second matches to the bike lane status of the original, so we can then add the installation year
  left_join(., match.matr, by = &quot;rowid&quot;) %&gt;% 
  left_join(., match.matr, by = c(&quot;rowid&quot; = &quot;match_1&quot;)) %&gt;% 
  left_join(., match.matr, by = c(&quot;rowid&quot; = &quot;match_2&quot;)) %&gt;% 
  filter(!is.na(YEAR_INSTA.x) | !(is.na(YEAR_INSTA.y)) | !(is.na(YEAR_INSTA))) %&gt;% 
  rename(orig_bike_status = bike_lane.x,
         orig_year_insta = YEAR_INSTA.x) %&gt;% 
  # convert NAs to zeros and then get the sum of the three year_insta columns to complete the addition of installation years to the matched control observations
  replace_na(., list(orig_year_insta = 0, YEAR_INSTA.y = 0, YEAR_INSTA = 0)) %&gt;% 
  mutate(year_insta = orig_year_insta + YEAR_INSTA.y + YEAR_INSTA) %&gt;% 
  select(orig_bike_status, orig_year_insta, ROADTYPE, directionality, SHAPELEN, year_insta, geometry.x) %&gt;% 
  mutate(rowid = row_number())</code></pre>
<p>With the data now matched and installation years linked between the treatment and control groups, we can proceed to introduce the crash data.</p>
</div>
<div id="aggregating-crash-data-with-street-segments" class="section level3">
<h3>Aggregating crash data with street segments</h3>
<p>Linking the street segments to geolocated crash data requires adding buffers to the crash data data points and then counting the number of points intersecting each line segment.</p>
<pre class="r"><code>crash_buffer &lt;- st_read(&quot;./markdown_data/crash_analysis_dc/buffer_crash_bikes&quot;,
                 layer = &quot;buffer_crash_bikes&quot;)</code></pre>
<p>Geographic data points do not have any inherit size component; points must have a space component to identify intersections. I added a five-meter buffer to all crash data points in qGIS to visualize the buffers to ensure they do not create errors at intersections. This can be done in R, but the primary methods, such as rgeos’ gBuffer function, require that the added buffer measurements are in the coordinate reference system of the points data. This requires a little more thinking (and likely visualization regardless), so qGIS simplifies the buffer creation and visualization. In many instances, the geographic location of the crashes line along the street centerlines, while others are adjacent to the street. These adjacent points might have occurred away from the street centerline, such as on the sidewalk, or they might have slight errors in coordinate locations.</p>
<p>Counting the number of points intersecting each line segment is simple with the sf package’s st_intersction function.</p>
<pre class="r"><code>line_crash_intersect.df &lt;- 
  join.match2 %&gt;% 
 # filter(year_insta &gt;= 2014) %&gt;% 
  st_intersection(., crash_buffer) %&gt;% 
  mutate(
    bike_yr_occur = case_when(
        TOTAL_B != &quot;0&quot; &amp; 
        year_insta - lubridate::year(REPORTD) &lt;= 2 &amp; 
          year_insta - lubridate::year(REPORTD) &gt; 0 ~ &quot;post_2yr&quot;,
        TOTAL_B != &quot;0&quot; &amp;
        year_insta - lubridate::year(REPORTD) &gt;= -3 &amp; 
          year_insta - lubridate::year(REPORTD) &lt;= 0 ~ &quot;pre_2yr&quot;,
        TRUE ~ &quot;FAIL&quot;),
    bike_car_yr_occur = case_when(
                              bike_cr == 1 &amp; 
                              year_insta - lubridate::year(REPORTD) &lt;= 2 &amp; 
                                year_insta - lubridate::year(REPORTD) &gt; 0 ~ &quot;post_2yr&quot;,
                              bike_cr == 1 &amp;
                               year_insta - lubridate::year(REPORTD) &gt;= -3 &amp; 
                                year_insta - lubridate::year(REPORTD) &lt;= 0 ~ &quot;pre_2yr&quot;,
                                TRUE ~ &quot;FAIL&quot;)) </code></pre>
<p>We now summarize the segments by whether they have bike lanes (org_bk_) and then by aggregate total crashes before and after the installation year (bike_yr_occur). This summarization tells how how many crashes occurred before and after the nominal “installation year” understanding that the group with org_bk_ = 0 never had a bike lane and only adopted the value of the matching segment with a bike lane.</p>
<pre class="r"><code>difference_of_differences &lt;- 
  line_crash_intersect.df %&gt;% 
  group_by(orig_year_insta, bike_yr_occur) %&gt;%
  summarise(n = n()) %&gt;% 
  ungroup() 
  
difference_of_differences</code></pre>
<pre><code>## Simple feature collection with 12 features and 3 fields
## geometry type:  MULTILINESTRING
## dimension:      XY
## bbox:           xmin: -77.09616 ymin: 38.8361 xmax: -76.91857 ymax: 38.96498
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## # A tibble: 12 x 4
##    orig_year_insta bike_yr_occur     n                          geometry.x
##              &lt;dbl&gt; &lt;chr&gt;         &lt;int&gt;               &lt;MULTILINESTRING [°]&gt;
##  1               0 FAIL             34 ((-76.99498 38.88328, -76.99498 38…
##  2               0 post_2yr         69 ((-76.99361 38.83993, -76.9936 38.…
##  3               0 pre_2yr         230 ((-76.99285 38.85843, -76.99273 38…
##  4            2014 FAIL             34 ((-76.99147 38.87398, -76.99146 38…
##  5            2014 post_2yr         27 ((-77.00207 38.90021, -77.00204 38…
##  6            2014 pre_2yr         166 ((-77.00603 38.83803, -77.00606 38…
##  7            2015 FAIL              8 ((-77.00778 38.89687, -77.00777 38…
##  8            2015 post_2yr         13 ((-77.0281 38.89507, -77.0281 38.8…
##  9            2015 pre_2yr          46 ((-77.01788 38.87343, -77.01795 38…
## 10            2016 FAIL             14 ((-76.9962 38.88379, -76.99618 38.…
## 11            2016 post_2yr         30 ((-77.0199 38.8973, -77.0199 38.89…
## 12            2016 pre_2yr          70 ((-76.9889 38.88923, -76.9888 38.8…</code></pre>
</div>
<div id="conclusions" class="section level3">
<h3>Conclusions</h3>
<p>The resulting dataset does not include enough data points to analyze because many bike lanes were installed before the crash data began collection in 2011 meaning there is missing pre-installation data for these segments. Additionally, the matching algorithm significantly limits the included crashes. I will generalize the analytical workflow to more quickly analyze another dataset that is robust and large enough for further analysis.</p>
</div>
</div>

                        </div>
                    </section>
            </div>
            
        <!-- Footer -->
            
                <!-- Footer -->
    <footer id="footer">
        <div class="inner">
            <ul class="icons">
                
                    <li><a href="https://www.facebook.com/dan.bernstein.771?ref=bookmarks" class="icon alt fa-facebook" target="_blank"><span class="label">Facebook</span></a></li>
                
                    <li><a href="https://www.instagram.com/dan_bernstein88/" class="icon alt fa-instagram" target="_blank"><span class="label">Instagram</span></a></li>
                
                    <li><a href="https://github.com/danbernstein?tab=repositories" class="icon alt fa-github" target="_blank"><span class="label">GitHub</span></a></li>
                
                    <li><a href="https://www.linkedin.com/in/danbernstein94/" class="icon alt fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
                
            </ul>
            <ul class="copyright">
                
                <li>Design:  <a href="https://www.html5up.net">HTML5 UP</a></li>
                
            </ul>
        </div>
    </footer>

            
        </div>

    <!-- Scripts -->
        <!-- Scripts -->
    <!-- jQuery -->
    <script src="https://danbernstein.netlify.com/js/jquery.min.js"></script>
    <script src="https://danbernstein.netlify.com/js/jquery.scrolly.min.js"></script>
    <script src="https://danbernstein.netlify.com/js/jquery.scrollex.min.js"></script>
    <script src="https://danbernstein.netlify.com/js/skel.min.js"></script>
    <script src="https://danbernstein.netlify.com/js/util.js"></script>

    

    <!-- Main JS -->
    <script src="https://danbernstein.netlify.com/js/main.js"></script>

    

    
        

    </body>
</html>
